# 第三章 目标文件里有什么

## 如何把二进制文件作为目标文件中的一个段

Q：如果我们要将一个二进制文件，比如图片、MP3 音乐、词典一类的东西作为目标文件中的一个段，该怎么做呢？
A：可以使用 objcopy 工具，比如我们有一个图片文件 “image.jpg”，大小为 0x82100 字节:

```sh
$ objcopy -I binary -O e1f32-i386 -B i386 image.jpg image.o
$ objdump -ht image.o
image.o:    file format e1f32-1386

Sections:
Idx Name        Size      VMA       LMA      File off Align
0 .data       00081200  00000000  00000000 00000034 2**0
                CONTENTS, ALLOC, LOAD, DATA

SYMBOL TABLE:
00000000 1    d .data 00000000 .daca
00000000 g      .data 00000000 _binary_image_jpg_start
00081200 g      .data 00000000 _binary_image_jpg_end
00081200 g      *ABS* 00000000 _binary_image_jpg_size
```

符号“_binary_image_jpg_start”、“_binary_image_jpg_end”和“_bimary_image_jpg_size”分别表示该图片文件在内存中的起始地址、结束地址和大小，我们可以在程序里面让接声明并使用它们。

## 自定义段

正常情况下，GCC 编译出来的目标文件中，代码会被放到 .text 段，全局变量和静态变量会被放到 .data 和 .bss 段， 正如我们前面所分析的。但是有时候你可能希望变量或某些部分代码能够放到你所指定的段中去，以实现某些特定的功能。比如为了满足某些硬件的内存和 I/O 的地址布局， 或者是像 Linux 操作系统内核中用来完成一些初给化和用户空间复制时出现页错误异常等。GCC 提供了一个扩展机制，使得程序员可以指定变量所处的段:

```c
__attribute__((section("FOO"))) int global = 42;
__attribute__((section("BAR"))) void foo()
{
}
```

我们在全局变量或函数之前加上 __atribute__((section("name"))) 属性就可以把相应的变量或 函数放到以 name 作为段名的段中。

## 强弱引用

我们经常在编程中碰到一种情况叫 符号重复定义。多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候将会出现符号重复定义的错误。比如我们在目标文件 A 和目标文件 B 都定义了一个全局整形变量 global，并将它们都初始化，那么链接器将 A 和 B 进行链接时会报错:

```sh
b.o:(.data+0x0): multiple definition of `glcbal'，
a.o:(.data+0x0): first defined here
```

这种符号的定义可以被称为 强符号(Strong Symbol)。有些符号的定义可以被称为 弱符号(Weak Symbol)。对于 C/C++ 语言来说，编译器默认函数和初始化了的全局变最为强符号，未初始化的全局变量为弱符号。我们也可以通过 GCC 的 __attribute__((weak)) 来定义任何一个强符号为弱符号。注意，强符号和弱符号都是针对定义来说的，不是针对符号的引用。比如我们有下面这段程序，

```cpp
extern int ext;
int weak;
int strong = 1;

__attribute__((weak)) weak2 = 2;
int main()
{
    return 0;
}
```

上面这段程序中，weak 和 weak2 是弱符号，strong 和 main 是强符号，而 ext 既非强符号也非弱符号，因为它是一个外部变量的引用。针对强弱符号的概念，链接器就会按如下规则处理与选择被多次定义的全局符号：

规则 1: 不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）， 如果有多个强符号定义，则链接器报符号重复定义错误。

规则 2: 如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。

规则 3: 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。比如目标文件 A 定义全局变量 global 为 int 型，占 4 个字节；目标文件 B 定义 global 为 double 型，占 8 个字节，那么目标文件 A 和 B 链接后，符号 global 占 8 个字节（尽量不要使用多个不同类型的弱符号，和否则容易导致很难发现的程序错误）。

弱引用和强引用:
目前我们所看到的对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，它们须要被正确决议，如果没有找到该符号的定义，链接器就会报符号未定义错误，这种被称为 强引用(Strong Reference)。与之相对应还有一种 弱引用(Weak Reference)，在处理弱引用时，如果该符号有定义，则链接器将该符号的引用决议；如果该符号未被定义，则链接器对于该引用不报错。链接器处理强引用和弱引用的过程几乎一样，只是对于未定义的弱引用，链接器不认为它是一个错误。一般对于未定义的弱引用，链接器默认其为 0，或者是一个特殊的值，以便于程序代码能够识别。弱引用和弱符号主要用于库的链接过程，我们将在“库”这一章再来详细讲述。弱符号跟链接器的 COMMON 块概念联系很上紧密，我们在后面“深入静态链接”这一章中的“COMMON 块”一节还会回顾弱符号的概念。

在 GCC 中，我们可以通过使用 __attribute__((weakref) 这个扩展关键字来声明对一个外部函数的引用为弱引用，比如下面这段代码:

```cpp
__attribute__ ((weakref)) void foo();

int main() {
    foo();
}
```

我们可以将它编译成一个可执行文件，GCC 并不会报链接错误。但是当我们运行这个可执行文件时，会发生运行错误。因为当 main 函数试图调用 foo 函数时，foo 函数的地址为 0，于是发生了非法地址访问的错误。一个改进的例子是:

```cpp
__attribute__ ((weakref)) void foo();

int main() {
    if(foo) foo();
}
```